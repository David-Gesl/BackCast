<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js FBX Loader</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
                "three/addons/": "https://threejs.org/examples/jsm/",
                "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js",
                "three/examples/jsm/loaders/FBXLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/FBXLoader.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js' 
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js'

        let scene, camera, renderer, controls, directionalLight, lampLight;

        const gui = new GUI();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 'black' );

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
            scene.add(ambientLight);

            // Add point light outside of the window
            const moonLight = new THREE.PointLight(0xFFFFFF, 0.1);
            // const helper = new THREE.PointLightHelper(moonLight);
            moonLight.position.set(-115, 80, -300);
            // scene.add(helper);
            // gui.add(moonLight, 'intensity', 0, 200, 0.01);
            // gui.add(moonLight.position, 'x', -500, 500, 1);
            // gui.add(moonLight.position, 'y', 0, 500, 1);
            // gui.add(moonLight.position, 'z', -500, 500, 1);
            // scene.add(moonLight);

            // Add the lamp light
            lampLight = new THREE.SpotLight(0xffb74d, 1);
            const lampLight2 = new THREE.PointLight(0xffb74d, 0.1);
            const helper = new THREE.PointLightHelper(lampLight2);
            lampLight2.position.set(-10, 10.5, -2.5);
            lampLight.position.set(-10, 12, -1);
            lampLight.penumbra = 0.8;
            lampLight.angle = THREE.MathUtils.degToRad(180);
            // lampLight.target.angle = THREE.MathUtils.degToRad(-30);
            lampLight.target.position.set(5, -10, -15);
            lampLight.castShadow = true;
            scene.add(lampLight);
            scene.add(lampLight2);
            scene.add(helper);
            scene.add(lampLight.target)

            // Load Radio model
            const fbx_loader = new FBXLoader();
            fbx_loader.load('radio/radio.fbx', (object) => {
                object.traverse((child) => {
                    if (child.isMesh) {
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load('radio/textures/blinn1_Base_color.png');
                        child.material.map = texture;
                        child.material.needsUpdate = true;
                    }
                });
                scene.add(object);
                object.position.set(7, 12, -8.5);
            });

            // const mtl_loader = new MTLLoader();
            // mtl_loader.load('room2/room.mtl', (materials) => {
            //     materials.preload();

            //     const obj_loader = new OBJLoader();
            //     obj_loader.setMaterials(materials);
            //     obj_loader.load('room2/room.obj', (object) => {
            //         scene.add(object);
            //         object.position.set(0, 0, 0);
            //     })
            // });

            // Procedural wood material
            const woodMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 1.0 },
                    woodColor: { value: new THREE.Color(0x8B4513) }, // brown color for wood
                    ringColor: { value: new THREE.Color(0xDEB887) }  // lighter color for rings
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 woodColor;
                    uniform vec3 ringColor;
                    varying vec2 vUv;

                    // Simple noise function
                    float noise(vec2 p) {
                        return sin(p.x) * sin(p.y);
                    }

                    void main() {
                        // Wood grain effect
                        float n = noise(vUv * 10.0);
                        float rings = abs(sin(vUv.x * 10.0 + n * 4.0));
                        vec3 color = mix(woodColor, ringColor, rings);

                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            // Load room
            const gltf_loader = new GLTFLoader();
            gltf_loader.load('room2/room2.gltf', (gltf) => {
                const object = gltf.scene;

                object.position.set(0, 0, 0);
                object.scale.set(10, 10, 10);
                scene.add(object);

                object.traverse((node) => {
                    if (node.isMesh) {
                        node.material.needsUpdate = true;
                    }
                });

                // compute the box that contains all the stuff
                // from object and below
                const box = new THREE.Box3().setFromObject( object );

                const boxSize = box.getSize( new THREE.Vector3() ).length();
                const boxCenter = box.getCenter( new THREE.Vector3() );

                // set the camera to frame the box
                frameArea( boxSize * 0.5, boxSize, boxCenter, camera );

                // update the Trackball controls to handle the new size
                controls.maxDistance = boxSize * 10;
                controls.target.copy( boxCenter );
                controls.update();
            })

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        class DegRadHelper {

            constructor( obj, prop ) {

                this.obj = obj;
                this.prop = prop;

            }
            get value() {

                return THREE.MathUtils.radToDeg( this.obj[ this.prop ] );

            }
            set value( v ) {

                this.obj[ this.prop ] = THREE.MathUtils.degToRad( v );

            }

        }

        function frameArea( sizeToFitOnScreen, boxSize, boxCenter, camera ) {

            const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
            const halfFovY = THREE.MathUtils.degToRad( camera.fov * .5 );
            const distance = halfSizeToFitOnScreen / Math.tan( halfFovY );
            // compute a unit vector that points in the direction the camera is now
            // in the xz plane from the center of the box
            const direction = ( new THREE.Vector3() )
                .subVectors( camera.position, boxCenter )
                .multiply( new THREE.Vector3( 1, 0, 1 ) )
                .normalize();

            // move the camera to a position distance units way from the center
            // in whatever direction the camera was from the center already
            camera.position.copy( direction.multiplyScalar( distance ).add( boxCenter ) );

            // pick some near and far values for the frustum that
            // will contain the box.
            camera.near = boxSize / 100;
            camera.far = boxSize * 100;

            camera.updateProjectionMatrix();

            // point the camera to look at the center of the box
            camera.lookAt( boxCenter.x, boxCenter.y, boxCenter.z );

        }

        function resizeRendererToDisplaySize( renderer ) {

            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if ( needResize ) {

                renderer.setSize( width, height, false );

            }

            return needResize;

        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            if ( resizeRendererToDisplaySize( renderer ) ) {

                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();

            }
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>
